name: Copilot Review Enforcer

on:
  pull_request_review_comment:
    types: [created]
  # Don't use issue_comment - too noisy
  schedule:
    # Fallback: Check every 5 minutes if reviews are pending
    - cron: '*/5 * * * *'
  workflow_dispatch:

permissions:
  contents: read
  pull-requests: write
  issues: write
  checks: write

jobs:
  enforce-copilot-review:
    name: Check Copilot Review Status
    runs-on: ubuntu-latest
    
    steps:
      - name: Get PR Information
        id: pr-info
        uses: actions/github-script@v7
        with:
          script: |
            let prNumber = null;
            
            if (context.eventName === 'pull_request_review_comment') {
              prNumber = context.payload.pull_request.number;
            } else if (context.eventName === 'schedule' || context.eventName === 'workflow_dispatch') {
              // For scheduled runs, check all open PRs
              const { data: prs } = await github.rest.pulls.list({
                owner: context.repo.owner,
                repo: context.repo.repo,
                state: 'open'
              });
              
              // Check the first open PR (or modify to check all)
              if (prs.length > 0) {
                prNumber = prs[0].number;
                console.log(`Checking PR #${prNumber}`);
              }
            }
            
            if (!prNumber) {
              console.log('No PR to check');
              return null;
            }
            
            return prNumber;

      - name: Analyze Copilot Review Comments
        if: steps.pr-info.outputs.result != 'null'
        uses: actions/github-script@v7
        with:
          script: |
            const prNumber = ${{ steps.pr-info.outputs.result }};
            
            console.log(`Analyzing PR #${prNumber}`);
            
            // Get PR review comments (inline code comments)
            const { data: reviewComments } = await github.rest.pulls.listReviewComments({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: prNumber,
            });
            
            console.log(`Total review comments: ${reviewComments.length}`);
            
            // Filter for actual Copilot comments (not "review requested" notifications)
            const copilotComments = reviewComments.filter(comment => {
              const isCopilotUser = comment.user.login.toLowerCase().includes('copilot') || 
                                   comment.user.type === 'Bot';
              
              // Make sure it's an actual review comment, not just a notification
              const hasSubstantiveContent = comment.body && 
                                           comment.body.length > 50 && // Real reviews are longer
                                           !comment.body.includes('requested a review') &&
                                           !comment.body.includes('has been requested');
              
              return isCopilotUser && hasSubstantiveContent;
            });
            
            console.log(`Copilot review comments: ${copilotComments.length}`);
            
            // If no Copilot comments yet, don't fail - just note it
            if (copilotComments.length === 0) {
              console.log('⏳ Waiting for Copilot to complete review...');
              
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: prNumber,
                body: `## ⏳ Waiting for Copilot Review\n\nCopilot review has been requested but not yet completed.\n\nThis check will update automatically when Copilot posts review comments.`
              });
              
              // Don't fail - just exit
              return;
            }
            
            // Analyze the actual review comments
            let criticalIssues = [];
            let highPriorityIssues = [];
            let suggestions = [];
            
            const criticalKeywords = [
              'sql injection', 'xss', 'cross-site scripting',
              'security vulnerability', 'hardcoded password', 'hardcoded secret',
              'authorization', 'authentication', 'csrf',
              'password in', 'secret in', 'api key',
              'remote code execution', 'path traversal',
              'insecure', 'vulnerable', 'exploit'
            ];
            
            const highPriorityKeywords = [
              'synchronous', 'blocking', 'thread', 'deadlock',
              'async', 'await', 'tolist()', '.result', '.wait()',
              'n+1', 'performance', 'memory leak',
              'error handling', 'exception', 'try-catch',
              'null reference', 'nullreferenceexception',
              'input validation', 'validate input'
            ];
            
            const suggestionKeywords = [
              'consider', 'could', 'might want to', 'suggestion',
              'refactor', 'simplify', 'improve readability',
              'documentation', 'comment', 'naming'
            ];
            
            copilotComments.forEach(comment => {
              const body = comment.body.toLowerCase();
              const firstLine = comment.body.split('\n')[0];
              
              // Check for explicit emoji markers first
              if (body.includes('🔴') || firstLine.toLowerCase().includes('critical')) {
                criticalIssues.push({
                  url: comment.html_url,
                  snippet: firstLine.substring(0, 100),
                  body: comment.body
                });
              }
              else if (body.includes('🟠') || firstLine.toLowerCase().includes('high priority')) {
                highPriorityIssues.push({
                  url: comment.html_url,
                  snippet: firstLine.substring(0, 100),
                  body: comment.body
                });
              }
              // Then check for keywords
              else if (criticalKeywords.some(keyword => body.includes(keyword))) {
                criticalIssues.push({
                  url: comment.html_url,
                  snippet: firstLine.substring(0, 100),
                  body: comment.body,
                  detectedBy: 'keyword'
                });
              }
              else if (highPriorityKeywords.some(keyword => body.includes(keyword))) {
                highPriorityIssues.push({
                  url: comment.html_url,
                  snippet: firstLine.substring(0, 100),
                  body: comment.body,
                  detectedBy: 'keyword'
                });
              }
              else if (suggestionKeywords.some(keyword => body.includes(keyword))) {
                suggestions.push({
                  url: comment.html_url,
                  snippet: firstLine.substring(0, 100)
                });
              }
              else {
                // Default to suggestion if can't categorize
                suggestions.push({
                  url: comment.html_url,
                  snippet: firstLine.substring(0, 100)
                });
              }
            });
            
            console.log(`Critical: ${criticalIssues.length}`);
            console.log(`High Priority: ${highPriorityIssues.length}`);
            console.log(`Suggestions: ${suggestions.length}`);
            
            // Log what we found
            if (criticalIssues.length > 0) {
              console.log('\nCritical Issues Found:');
              criticalIssues.forEach((issue, i) => {
                console.log(`${i + 1}. ${issue.snippet}`);
              });
            }
            
            if (highPriorityIssues.length > 0) {
              console.log('\nHigh Priority Issues Found:');
              highPriorityIssues.forEach((issue, i) => {
                console.log(`${i + 1}. ${issue.snippet}`);
              });
            }
            
            // Create detailed status message
            const statusIcon = criticalIssues.length > 0 ? '❌' : 
                              highPriorityIssues.length > 3 ? '⚠️' : '✅';
            const statusText = criticalIssues.length > 0 ? 'BLOCKED' : 
                              highPriorityIssues.length > 3 ? 'NEEDS ATTENTION' : 'APPROVED';
            
            let statusMessage = `## ${statusIcon} Copilot Review Status: ${statusText}\n\n`;
            statusMessage += `**Review Complete:** ${copilotComments.length} substantive comment(s) from Copilot\n\n`;
            statusMessage += `**Issue Breakdown:**\n`;
            statusMessage += `- 🔴 **Critical:** ${criticalIssues.length} ${criticalIssues.length > 0 ? '(MUST FIX)' : ''}\n`;
            statusMessage += `- 🟠 **High Priority:** ${highPriorityIssues.length} ${highPriorityIssues.length > 3 ? '(Should address)' : ''}\n`;
            statusMessage += `- 💡 **Suggestions:** ${suggestions.length}\n\n`;
            
            // Add details for critical issues
            if (criticalIssues.length > 0) {
              statusMessage += `### ❌ Merge Blocked - Critical Issues\n\n`;
              statusMessage += `The following critical issues must be resolved:\n\n`;
              criticalIssues.forEach((issue, i) => {
                statusMessage += `${i + 1}. [${issue.snippet}](${issue.url})\n`;
              });
              statusMessage += `\n**Action Required:** Fix all critical issues before requesting human review.\n\n`;
            }
            
            // Add details for high priority issues
            if (highPriorityIssues.length > 0) {
              statusMessage += `### 🟠 High Priority Issues\n\n`;
              if (highPriorityIssues.length > 3) {
                statusMessage += `**Warning:** ${highPriorityIssues.length} high-priority issues detected. While not blocking, these should be addressed.\n\n`;
              }
              statusMessage += `<details>\n<summary>View High Priority Issues (${highPriorityIssues.length})</summary>\n\n`;
              highPriorityIssues.slice(0, 10).forEach((issue, i) => {
                statusMessage += `${i + 1}. [${issue.snippet}](${issue.url})\n`;
              });
              if (highPriorityIssues.length > 10) {
                statusMessage += `\n... and ${highPriorityIssues.length - 10} more\n`;
              }
              statusMessage += `\n</details>\n\n`;
            }
            
            // Add suggestions
            if (suggestions.length > 0) {
              statusMessage += `### 💡 Suggestions for Improvement\n\n`;
              statusMessage += `Copilot provided ${suggestions.length} suggestion(s) that could improve code quality.\n\n`;
            }
            
            if (criticalIssues.length === 0 && highPriorityIssues.length <= 3) {
              statusMessage += `### ✅ Ready for Review\n\n`;
              statusMessage += `No blocking issues detected. This PR is ready for human review!\n\n`;
            }
            
            statusMessage += `---\n\n`;
            statusMessage += `<details>\n<summary>📋 Classification Criteria</summary>\n\n`;
            statusMessage += `**Critical (Blocks PR):**\n`;
            statusMessage += `- Security vulnerabilities (SQL injection, XSS, etc.)\n`;
            statusMessage += `- Hardcoded credentials or secrets\n`;
            statusMessage += `- Missing authentication/authorization\n`;
            statusMessage += `- Data integrity risks\n\n`;
            statusMessage += `**High Priority (Should Fix):**\n`;
            statusMessage += `- Synchronous I/O operations\n`;
            statusMessage += `- Missing error handling\n`;
            statusMessage += `- Performance issues (N+1 queries, etc.)\n`;
            statusMessage += `- Input validation missing\n\n`;
            statusMessage += `**Suggestions (Nice to Have):**\n`;
            statusMessage += `- Code style improvements\n`;
            statusMessage += `- Refactoring opportunities\n`;
            statusMessage += `- Documentation additions\n`;
            statusMessage += `\n</details>`;
            
            // Post or update the status comment
            const { data: existingComments } = await github.rest.issues.listComments({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: prNumber,
            });
            
            const botComment = existingComments.find(c => 
              c.user.login === 'github-actions[bot]' && 
              (c.body.includes('Copilot Review Status') || c.body.includes('Waiting for Copilot Review'))
            );
            
            if (botComment) {
              await github.rest.issues.updateComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                comment_id: botComment.id,
                body: statusMessage
              });
              console.log('✅ Updated status comment');
            } else {
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: prNumber,
                body: statusMessage
              });
              console.log('✅ Created status comment');
            }
            
            // Set workflow status
            if (criticalIssues.length > 0) {
              core.setFailed(`❌ ${criticalIssues.length} critical issue(s) must be resolved before merging.`);
            } else {
              console.log(`✅ No critical issues found. High: ${highPriorityIssues.length}, Suggestions: ${suggestions.length}`);
            }
